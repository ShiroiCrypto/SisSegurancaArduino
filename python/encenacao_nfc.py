import csv
from datetime import datetime
import mcpi.minecraft as minecraft
import mcpi.block as block
from math import *
import serial
import time
import os
import sys
import io

# For√ßa codifica√ß√£o UTF-8 no console do Windows
if sys.platform == "win32":
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

# Configura√ß√µes
MINECRAFT_HOST = "26.127.43.27"  # IP do servidor via Radmin VPN
MINECRAFT_PORT = 4711  # Porta do RaspberryJuice
ARDUINO_PORT = "COM5"  # Ajuste para sua porta (ex: '/dev/ttyUSB0' no Linux)
ARDUINO_BAUDRATE = 9600
LOG_FILE = "logs/encenacao_nfc_log.csv"

# Configura√ß√µes da encena√ß√£o
PORTA_X, PORTA_Y, PORTA_Z = 445, 72, -419  # Posi√ß√£o da porta
ARCO_X, ARCO_Y, ARCO_Z = 445, 72, -419     # Posi√ß√£o do arco-√≠ris
ESTRELA_X, ESTRELA_Y, ESTRELA_Z = 445, 72, -419  # Posi√ß√£o da estrela

# Inicializa o CSV de logs
def inicializar_log():
    if not os.path.exists(LOG_FILE):
        os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
        with open(LOG_FILE, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["Timestamp", "Status", "Detalhes"])
    print(f"[INFO] Arquivo de log inicializado em {LOG_FILE}")

# Fun√ß√£o para registrar log
def registrar_log(status, detalhes):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    try:
        with open(LOG_FILE, 'a', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow([timestamp, status, detalhes])
        print(f"[{timestamp}] {status}: {detalhes}")
    except Exception as e:
        print(f"[ERROR] Falha ao registrar log: {e}")

# Fun√ß√£o para criar a porta de encena√ß√£o
def criar_porta_encenacao(mc):
    """Cria uma porta de ferro para a encena√ß√£o"""
    try:
        # Cria uma porta de ferro 2x3
        for y in range(3):
            for x in range(2):
                mc.setBlock(PORTA_X + x, PORTA_Y + y, PORTA_Z, block.IRON_BLOCK.id)
        
        # Adiciona ma√ßanetas (blocos de ouro)
        mc.setBlock(PORTA_X, PORTA_Y + 1, PORTA_Z, block.GOLD_BLOCK.id)
        mc.setBlock(PORTA_X + 1, PORTA_Y + 1, PORTA_Z, block.GOLD_BLOCK.id)
        
        # Adiciona uma placa com texto
        mc.setBlock(PORTA_X + 1, PORTA_Y + 3, PORTA_Z, block.SIGN.id)
        
        registrar_log("DOOR", "Porta de encena√ß√£o criada")
        print(f"[INFO] Porta de encena√ß√£o criada em x={PORTA_X}, y={PORTA_Y}, z={PORTA_Z}")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao criar porta: {e}")
        print(f"[ERROR] Falha ao criar porta: {e}")

# Fun√ß√£o para abrir a porta dramaticamente
def abrir_porta_dramatica(mc):
    """Abre a porta com efeitos dram√°ticos"""
    try:
        mc.postToChat("üö™ A porta est√° se abrindo...")
        
        # Efeito de part√≠culas na porta
        for i in range(8):
            mc.postToChat(f"‚ú® Efeito m√°gico {i+1}/8...")
            time.sleep(1.0)  # Mais tempo entre cada efeito
        
        # Remove a porta (abre)
        for y in range(3):
            for x in range(2):
                mc.setBlock(PORTA_X + x, PORTA_Y + y, PORTA_Z, block.AIR.id)
        
        mc.postToChat("üåü A porta se abriu! O caminho est√° livre!")
        registrar_log("DOOR_OPEN", "Porta aberta dramaticamente")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao abrir porta: {e}")
        print(f"[ERROR] Falha ao abrir porta: {e}")

# Fun√ß√£o para fechar a porta dramaticamente
def fechar_porta_dramatica(mc):
    """Fecha a porta com efeitos dram√°ticos"""
    try:
        mc.postToChat("üö™ A porta est√° se fechando...")
        
        # Efeito de part√≠culas
        for i in range(5):
            mc.postToChat(f"üí´ Efeito de fechamento {i+1}/5...")
            time.sleep(0.8)  # Mais tempo entre cada efeito
        
        # Recria a porta
        for y in range(3):
            for x in range(2):
                mc.setBlock(PORTA_X + x, PORTA_Y + y, PORTA_Z, block.IRON_BLOCK.id)
        
        # Adiciona ma√ßanetas
        mc.setBlock(PORTA_X, PORTA_Y + 1, PORTA_Z, block.GOLD_BLOCK.id)
        mc.setBlock(PORTA_X + 1, PORTA_Y + 1, PORTA_Z, block.GOLD_BLOCK.id)
        
        mc.postToChat("üîí A porta se fechou! O acesso foi negado!")
        registrar_log("DOOR_CLOSE", "Porta fechada dramaticamente")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao fechar porta: {e}")
        print(f"[ERROR] Falha ao fechar porta: {e}")

# Fun√ß√£o para criar arco-√≠ris de encena√ß√£o
def criar_arco_iris_encenacao(mc):
    """Cria um arco-√≠ris para a encena√ß√£o"""
    try:
        height = 30
        colors = [10, 11, 6]  # Roxo, Azul, Rosa
        
        mc.postToChat("üåà Criando arco-√≠ris m√°gico...")
        
        # Constr√≥i o arco-√≠ris
        for x in range(0, 80):
            for colourindex in range(0, len(colors)):
                y = sin((x / 80.0) * pi) * height + colourindex + ARCO_Y
                mc.setBlock(x - 40 + ARCO_X, y, ARCO_Z, block.WOOL.id, colors[len(colors) - 1 - colourindex])
            
            # Mensagens de progresso
            if x % 20 == 0:  # A cada 20 blocos
                progresso = (x / 80) * 100
                mc.postToChat(f"üé® Progresso do arco-√≠ris: {progresso:.0f}%")
            
            time.sleep(0.1)  # Mais tempo para ver a constru√ß√£o
        
        mc.postToChat("‚ú® Arco-√≠ris m√°gico criado!")
        registrar_log("RAINBOW", "Arco-√≠ris de encena√ß√£o criado")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao criar arco-√≠ris: {e}")
        print(f"[ERROR] Falha ao criar arco-√≠ris: {e}")

# Fun√ß√£o para criar estrela de encena√ß√£o
def criar_estrela_encenacao(mc):
    """Cria uma estrela para a encena√ß√£o"""
    try:
        mc.postToChat("‚≠ê Criando estrela m√°gica...")
        
        # Cria uma estrela simples
        raio = 8
        for i in range(5):
            angulo = (i * 72) * pi / 180
            x = ESTRELA_X + int(raio * cos(angulo))
            y = ESTRELA_Y + int(raio * sin(angulo))
            mc.setBlock(x, y, ESTRELA_Z, block.WOOL.id, 4)  # Amarelo
        
        mc.postToChat("üåü Estrela m√°gica criada!")
        registrar_log("STAR", "Estrela de encena√ß√£o criada")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao criar estrela: {e}")
        print(f"[ERROR] Falha ao criar estrela: {e}")

# Fun√ß√£o para limpar a √°rea de encena√ß√£o
def limpar_encenacao(mc):
    """Limpa toda a √°rea de encena√ß√£o"""
    try:
        mc.postToChat("üßπ Limpando √°rea de encena√ß√£o...")
        
        # Limpa uma √°rea grande
        mc.setBlocks(ARCO_X - 50, ARCO_Y - 20, ARCO_Z - 10, 
                    ARCO_X + 50, ARCO_Y + 50, ARCO_Z + 10, block.AIR.id)
        
        mc.postToChat("‚ú® √Årea limpa! Pronta para nova encena√ß√£o!")
        registrar_log("CLEAR", "√Årea de encena√ß√£o limpa")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao limpar √°rea: {e}")
        print(f"[ERROR] Falha ao limpar √°rea: {e}")

# Fun√ß√£o para encena√ß√£o completa
def encenacao_completa(mc):
    """Executa uma encena√ß√£o completa"""
    try:
        mc.postToChat("üé≠ INICIANDO ENCENA√á√ÉO M√ÅGICA! üé≠")
        mc.postToChat("=" * 50)
        mc.postToChat("üìñ Esta encena√ß√£o ter√° 5 passos m√°gicos...")
        mc.postToChat("‚è∞ Cada passo levar√° alguns segundos para completar...")
        time.sleep(3)  # Tempo para ler as instru√ß√µes
        
        # Passo 1: Criar porta
        mc.postToChat("üö™ Passo 1: Criando porta m√°gica...")
        mc.postToChat("‚è≥ Aguarde enquanto a porta se materializa...")
        criar_porta_encenacao(mc)
        time.sleep(5)  # Mais tempo para ler
        
        # Passo 2: Abrir porta
        mc.postToChat("üîì Passo 2: Abrindo porta...")
        mc.postToChat("‚ú® A magia est√° se intensificando...")
        abrir_porta_dramatica(mc)
        time.sleep(6)  # Mais tempo para apreciar a abertura
        
        # Passo 3: Criar arco-√≠ris
        mc.postToChat("üåà Passo 3: Criando arco-√≠ris...")
        mc.postToChat("üé® As cores est√£o se formando no c√©u...")
        criar_arco_iris_encenacao(mc)
        time.sleep(5)  # Mais tempo para ver o arco-√≠ris
        
        # Passo 4: Criar estrela
        mc.postToChat("‚≠ê Passo 4: Criando estrela...")
        mc.postToChat("üåü A estrela est√° brilhando intensamente...")
        criar_estrela_encenacao(mc)
        time.sleep(4)  # Mais tempo para ver a estrela
        
        # Passo 5: Fechar porta
        mc.postToChat("üîí Passo 5: Fechando porta...")
        mc.postToChat("üåô O espet√°culo est√° chegando ao fim...")
        fechar_porta_dramatica(mc)
        time.sleep(3)  # Tempo final para apreciar
        
        mc.postToChat("üéâ ENCENA√á√ÉO CONCLU√çDA! üéâ")
        mc.postToChat("üëè Obrigado por assistir ao espet√°culo m√°gico!")
        mc.postToChat("‚ú® A magia do NFC e Minecraft em a√ß√£o!")
        time.sleep(4)  # Tempo final para ler as mensagens de conclus√£o
        registrar_log("SHOW", "Encena√ß√£o completa executada")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro na encena√ß√£o: {e}")
        print(f"[ERROR] Falha na encena√ß√£o: {e}")

# Conex√£o com Minecraft e Arduino
inicializar_log()
try:
    print("[INFO] Tentando conectar ao servidor Minecraft em {}:{}".format(MINECRAFT_HOST, MINECRAFT_PORT))
    mc = minecraft.Minecraft.create(MINECRAFT_HOST, MINECRAFT_PORT)
    print("[INFO] Conectado ao servidor Minecraft")
    registrar_log("START", "Conex√£o estabelecida com Minecraft")
    mc.postToChat("üé≠ Sistema de Encena√ß√£o NFC iniciado! Aproxime um cart√£o para a apresenta√ß√£o!")
except Exception as e:
    registrar_log("ERROR", f"Falha ao conectar ao Minecraft em {MINECRAFT_HOST}:{MINECRAFT_PORT}: {e}")
    print(f"[ERROR] Falha ao conectar ao Minecraft: {e}")
    exit(1)

try:
    print(f"[INFO] Tentando conectar ao Arduino na porta {ARDUINO_PORT}")
    arduino = serial.Serial(ARDUINO_PORT, ARDUINO_BAUDRATE, timeout=1)
    time.sleep(2)  # Estabiliza conex√£o
    print(f"[INFO] Conectado ao Arduino na porta {ARDUINO_PORT}")
    registrar_log("START", "Conex√£o estabelecida com Arduino")
except Exception as e:
    registrar_log("ERROR", f"Falha ao conectar ao Arduino na porta {ARDUINO_PORT}: {e}")
    print(f"[ERROR] Falha ao conectar ao Arduino: {e}")
    exit(1)

# Loop principal
try:
    while True:
        try:
            # Leitura do Arduino
            if arduino.in_waiting > 0:
                linha = arduino.readline().decode('utf-8', errors='ignore').strip()
                print(f"[INFO] Recebido do Arduino: {linha}")
                if not linha or ":" not in linha:
                    registrar_log("IGNORED", "Linha inv√°lida recebida do Arduino")
                    continue
                status, detalhes = linha.split(":", 1)
                registrar_log(status, detalhes)

                if status == "LENDO":
                    mc.postToChat("üì∂ Lendo cart√£o NFC...")
                elif status == "AUTORIZADO":
                    mc.postToChat("‚úÖ Acesso autorizado! Iniciando encena√ß√£o m√°gica...")
                    encenacao_completa(mc)
                elif status == "NEGADO":
                    mc.postToChat("üö´ Acesso negado! Limpando √°rea...")
                    limpar_encenacao(mc)
                elif status == "READY":
                    mc.postToChat("üü° Sistema pronto para nova encena√ß√£o.")
            time.sleep(0.1)  # Reduz uso de CPU
        except Exception as e:
            registrar_log("ERROR", f"Erro no loop principal: {e}")
            time.sleep(1)
except KeyboardInterrupt:
    print("[INFO] Script interrompido pelo usu√°rio (Ctrl+C)")
    registrar_log("STOP", "Script interrompido pelo usu√°rio")
    arduino.close()
    print("[INFO] Conex√£o com Arduino fechada")
    exit(0)
