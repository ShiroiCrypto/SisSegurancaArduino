import csv
from datetime import datetime
import mcpi.minecraft as minecraft
import mcpi.block as block
from math import *
import serial
import time
import os
import sys
import io

# For√ßa codifica√ß√£o UTF-8 no console do Windows
if sys.platform == "win32":
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8')

# Configura√ß√µes
MINECRAFT_HOST = "26.127.43.27"  # IP do servidor via Radmin VPN
MINECRAFT_PORT = 4711  # Porta do RaspberryJuice
ARDUINO_PORT = "COM5"  # Ajuste para sua porta (ex: '/dev/ttyUSB0' no Linux)
ARDUINO_BAUDRATE = 9600
LOG_FILE = "logs/encenacao_nfc_log.csv"

# Configura√ß√µes da encena√ß√£o (TODOS NA MESMA COORDENADA BASE PARA SOBREPOSI√á√ÉO)
BASE_X, BASE_Y, BASE_Z = 445, 72, -419
PORTA_X, PORTA_Y, PORTA_Z = BASE_X, BASE_Y, BASE_Z  # Posi√ß√£o da porta
ARCO_X, ARCO_Y, ARCO_Z = BASE_X, BASE_Y, BASE_Z    # Posi√ß√£o do arco-√≠ris
ESTRELA_X, ESTRELA_Y, ESTRELA_Z = BASE_X, BASE_Y, BASE_Z  # Posi√ß√£o da estrela

# Dimens√µes da porta (2 blocos de largura por 3 blocos de altura)
PORTA_LARGURA = 2
PORTA_ALTURA = 3
PORTA_MATERIAL = block.IRON_BLOCK.id
MOLDURA_MATERIAL = block.STONE_BRICK.id

# Inicializa o CSV de logs
def inicializar_log():
    if not os.path.exists(LOG_FILE):
        os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
        with open(LOG_FILE, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["Timestamp", "Status", "Detalhes"])
    print(f"[INFO] Arquivo de log inicializado em {LOG_FILE}")

# Fun√ß√£o para registrar log
def registrar_log(status, detalhes):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    try:
        with open(LOG_FILE, 'a', newline='', encoding='utf-8') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow([timestamp, status, detalhes])
        print(f"[{timestamp}] {status}: {detalhes}")
    except Exception as e:
        print(f"[ERROR] Falha ao registrar log: {e}")

# Fun√ß√£o para criar a porta de encena√ß√£o (MELHORADA COM MOLDURA)
def criar_porta_encenacao(mc):
    """Cria uma porta de ferro 2x3 com uma moldura de tijolos de pedra para destaque."""
    try:
        # 1. Cria a moldura (Frame) ao redor da porta (3x4)
        for y in range(-1, PORTA_ALTURA + 1):
            # Lados (x de -1 a 2)
            mc.setBlock(PORTA_X - 1, PORTA_Y + y, PORTA_Z, MOLDURA_MATERIAL)
            mc.setBlock(PORTA_X + PORTA_LARGURA, PORTA_Y + y, PORTA_Z, MOLDURA_MATERIAL)
        
        # Topo e Base
        for x in range(PORTA_LARGURA):
            mc.setBlock(PORTA_X + x, PORTA_Y - 1, PORTA_Z, MOLDURA_MATERIAL)
            mc.setBlock(PORTA_X + x, PORTA_Y + PORTA_ALTURA, PORTA_Z, MOLDURA_MATERIAL)

        # 2. Cria a porta principal (Iron Blocks)
        for y in range(PORTA_ALTURA):
            for x in range(PORTA_LARGURA):
                mc.setBlock(PORTA_X + x, PORTA_Y + y, PORTA_Z, PORTA_MATERIAL)
        
        # 3. Adiciona ma√ßanetas (blocos de ouro)
        mc.setBlock(PORTA_X, PORTA_Y + 1, PORTA_Z, block.GOLD_BLOCK.id)
        mc.setBlock(PORTA_X + 1, PORTA_Y + 1, PORTA_Z, block.GOLD_BLOCK.id)
        
        # 4. Adiciona uma placa (Sign)
        # O bloco de sinaliza√ß√£o deve ser colocado em uma posi√ß√£o onde haja um bloco s√≥lido atr√°s (a moldura)
        mc.setBlock(PORTA_X + PORTA_LARGURA, PORTA_Y + 1, PORTA_Z - 1, block.SIGN.id, 0)
        
        registrar_log("DOOR", "Porta de encena√ß√£o criada com moldura")
        print(f"[INFO] Porta de encena√ß√£o criada em x={PORTA_X}, y={PORTA_Y}, z={PORTA_Z}")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao criar porta: {e}")
        print(f"[ERROR] Falha ao criar porta: {e}")

# Fun√ß√£o para abrir a porta dramaticamente
def abrir_porta_dramatica(mc):
    """Abre a porta removendo o material principal, mantendo a moldura."""
    try:
        mc.postToChat("üö™ A porta est√° se abrindo...")
        
        # Efeito de part√≠culas na porta
        for i in range(8):
            mc.postToChat(f"‚ú® Efeito m√°gico {i+1}/8...")
            time.sleep(0.5)  # Tempo entre cada efeito
        
        # Remove a porta (abre)
        for y in range(PORTA_ALTURA):
            for x in range(PORTA_LARGURA):
                mc.setBlock(PORTA_X + x, PORTA_Y + y, PORTA_Z, block.AIR.id) # Remove Iron Blocks
        
        mc.postToChat("üåü A porta se abriu! O caminho est√° livre!")
        registrar_log("DOOR_OPEN", "Porta aberta dramaticamente")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao abrir porta: {e}")
        print(f"[ERROR] Falha ao abrir porta: {e}")

# Fun√ß√£o para fechar a porta dramaticamente
def fechar_porta_dramatica(mc):
    """Fecha a porta recriando o material principal."""
    try:
        mc.postToChat("üö™ A porta est√° se fechando...")
        
        # Efeito de part√≠culas
        for i in range(5):
            mc.postToChat(f"üí´ Efeito de fechamento {i+1}/5...")
            time.sleep(0.4) 
        
        # Recria a porta (Iron Blocks)
        for y in range(PORTA_ALTURA):
            for x in range(PORTA_LARGURA):
                mc.setBlock(PORTA_X + x, PORTA_Y + y, PORTA_Z, PORTA_MATERIAL)
        
        # Adiciona ma√ßanetas
        mc.setBlock(PORTA_X, PORTA_Y + 1, PORTA_Z, block.GOLD_BLOCK.id)
        mc.setBlock(PORTA_X + 1, PORTA_Y + 1, PORTA_Z, block.GOLD_BLOCK.id)
        
        mc.postToChat("üîí A porta se fechou! O acesso foi negado!")
        registrar_log("DOOR_CLOSE", "Porta fechada dramaticamente")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao fechar porta: {e}")
        print(f"[ERROR] Falha ao fechar porta: {e}")

# Fun√ß√£o para criar arco-√≠ris de encena√ß√£o
def criar_arco_iris_encenacao(mc):
    """Cria um arco-√≠ris para a encena√ß√£o na mesma coordenada da porta."""
    try:
        height = 30
        colors = [10, 11, 6]  # Roxo, Azul, Rosa
        
        mc.postToChat("üåà Criando arco-√≠ris m√°gico...")
        
        # Constr√≥i o arco-√≠ris (sobreposto √† porta aberta)
        for x in range(0, 80):
            for colourindex in range(0, len(colors)):
                y = sin((x / 80.0) * pi) * height + colourindex + ARCO_Y
                # Centraliza em ARCO_X
                mc.setBlock(x - 40 + ARCO_X, y, ARCO_Z, block.WOOL.id, colors[len(colors) - 1 - colourindex])
            
            # Mensagens de progresso
            if x % 20 == 0:
                progresso = (x / 80) * 100
                mc.postToChat(f"üé® Progresso do arco-√≠ris: {progresso:.0f}%")
            
            time.sleep(0.05) # Constru√ß√£o mais r√°pida
        
        mc.postToChat("‚ú® Arco-√≠ris m√°gico criado!")
        registrar_log("RAINBOW", "Arco-√≠ris de encena√ß√£o criado")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao criar arco-√≠ris: {e}")
        print(f"[ERROR] Falha ao criar arco-√≠ris: {e}")

# Fun√ß√£o para criar estrela de encena√ß√£o
def criar_estrela_encenacao(mc):
    """Cria uma estrela para a encena√ß√£o (sobreposta √† porta e arco-√≠ris)."""
    try:
        mc.postToChat("‚≠ê Criando estrela m√°gica...")
        
        # Cria uma estrela simples (pentagrama)
        raio = 8
        for i in range(5):
            angulo = (i * 72) * pi / 180
            x = ESTRELA_X + int(raio * cos(angulo))
            y = ESTRELA_Y + 15 + int(raio * sin(angulo)) # Um pouco mais alta
            
            # Desenha as pontas
            mc.setBlock(x, y, ESTRELA_Z, block.WOOL.id, 4)  # Amarelo
        
        # Adiciona o centro com um bloco de diamante para destaque
        mc.setBlock(ESTRELA_X, ESTRELA_Y + 15, ESTRELA_Z, block.DIAMOND_BLOCK.id)
        
        mc.postToChat("üåü Estrela m√°gica criada!")
        registrar_log("STAR", "Estrela de encena√ß√£o criada")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao criar estrela: {e}")
        print(f"[ERROR] Falha ao criar estrela: {e}")

# Fun√ß√£o para limpar a √°rea de encena√ß√£o
def limpar_encenacao(mc):
    """Limpa toda a √°rea de encena√ß√£o (Porta, Arco-√çris, Estrela)"""
    try:
        mc.postToChat("üßπ Limpando √°rea de encena√ß√£o...")
        
        # Limpa uma √°rea grande o suficiente para todas as constru√ß√µes sobrepostas
        mc.setBlocks(BASE_X - 50, BASE_Y - 20, BASE_Z - 10, 
                     BASE_X + 50, BASE_Y + 50, BASE_Z + 10, block.AIR.id)
        
        mc.postToChat("‚ú® √Årea limpa! Pronta para nova encena√ß√£o!")
        registrar_log("CLEAR", "√Årea de encena√ß√£o limpa")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro ao limpar √°rea: {e}")
        print(f"[ERROR] Falha ao limpar √°rea: {e}")

# Fun√ß√£o para encena√ß√£o completa
def encenacao_completa(mc):
    """Executa uma encena√ß√£o completa (Mant√©m a constru√ß√£o ap√≥s o Passo 5)."""
    try:
        mc.postToChat("üé≠ INICIANDO ENCENA√á√ÉO M√ÅGICA! üé≠")
        mc.postToChat("=" * 50)
        mc.postToChat("üìñ Esta encena√ß√£o ter√° 5 passos m√°gicos sobrepostos...")
        mc.postToChat("‚è∞ Cada passo levar√° alguns segundos para completar...")
        
        # Limpeza Inicial (Garante que a √°rea est√° vazia antes de come√ßar)
        limpar_encenacao(mc)
        mc.postToChat("üßπ √Årea limpa para iniciar.")
        time.sleep(2)
        
        # Passo 1: Criar porta
        mc.postToChat("üö™ Passo 1: Criando porta m√°gica com moldura...")
        mc.postToChat("‚è≥ Aguarde enquanto a porta se materializa...")
        criar_porta_encenacao(mc)
        time.sleep(3) 
        
        # Passo 2: Abrir porta
        mc.postToChat("üîì Passo 2: Abrindo porta...")
        mc.postToChat("‚ú® A magia est√° se intensificando, abrindo caminho...")
        abrir_porta_dramatica(mc)
        time.sleep(3) 
        
        # Passo 3: Criar arco-√≠ris (Aparece no espa√ßo da porta aberta)
        mc.postToChat("üåà Passo 3: Criando arco-√≠ris...")
        mc.postToChat("üé® As cores est√£o se formando no c√©u, dentro do portal...")
        criar_arco_iris_encenacao(mc)
        time.sleep(4) 
        
        # Passo 4: Criar estrela (Aparece sobre o arco-√≠ris)
        mc.postToChat("‚≠ê Passo 4: Criando estrela...")
        mc.postToChat("üåü A estrela est√° brilhando intensamente sobre as cores...")
        criar_estrela_encenacao(mc)
        time.sleep(3) 
        
        # Passo 5: Fechar porta (Recria apenas a porta, deixando arco-√≠ris e estrela intactos no fundo)
        mc.postToChat("üîí Passo 5: Fechando porta...")
        mc.postToChat("üåô O espet√°culo est√° chegando ao fim, fechando o portal...")
        fechar_porta_dramatica(mc)
        time.sleep(3) 
        
        mc.postToChat("üéâ ENCENA√á√ÉO CONCLU√çDA! üéâ")
        mc.postToChat("üëè A porta est√° fechada, mas o Arco-√çris e a Estrela est√£o mantidos!")
        registrar_log("SHOW", "Encena√ß√£o completa executada")
        
    except Exception as e:
        registrar_log("ERROR", f"Erro na encena√ß√£o: {e}")
        print(f"[ERROR] Falha na encena√ß√£o: {e}")

# Conex√£o com Minecraft e Arduino
inicializar_log()
try:
    print("[INFO] Tentando conectar ao servidor Minecraft em {}:{}".format(MINECRAFT_HOST, MINECRAFT_PORT))
    mc = minecraft.Minecraft.create(MINECRAFT_HOST, MINECRAFT_PORT)
    print("[INFO] Conectado ao servidor Minecraft")
    registrar_log("START", "Conex√£o estabelecida com Minecraft")
    mc.postToChat("üé≠ Sistema de Encena√ß√£o NFC iniciado! Aproxime um cart√£o para a apresenta√ß√£o!")
    # Teleporta o jogador para a √°rea para melhor visualiza√ß√£o
    mc.player.setPos(BASE_X, BASE_Y, BASE_Z - 10) 
except Exception as e:
    registrar_log("ERROR", f"Falha ao conectar ao Minecraft em {MINECRAFT_HOST}:{MINECRAFT_PORT}: {e}")
    print(f"[ERROR] Falha ao conectar ao Minecraft: {e}")
    exit(1)

try:
    print(f"[INFO] Tentando conectar ao Arduino na porta {ARDUINO_PORT}")
    arduino = serial.Serial(ARDUINO_PORT, ARDUINO_BAUDRATE, timeout=1)
    time.sleep(2)  # Estabiliza conex√£o
    print(f"[INFO] Conectado ao Arduino na porta {ARDUINO_PORT}")
    registrar_log("START", "Conex√£o estabelecida com Arduino")
except Exception as e:
    registrar_log("ERROR", f"Falha ao conectar ao Arduino na porta {ARDUINO_PORT}: {e}")
    print(f"[ERROR] Falha ao conectar ao Arduino: {e}")
    exit(1)

# Loop principal
try:
    while True:
        try:
            # Leitura do Arduino
            if arduino.in_waiting > 0:
                linha = arduino.readline().decode('utf-8', errors='ignore').strip()
                print(f"[INFO] Recebido do Arduino: {linha}")
                if not linha or ":" not in linha:
                    registrar_log("IGNORED", "Linha inv√°lida recebida do Arduino")
                    continue
                status, detalhes = linha.split(":", 1)
                registrar_log(status, detalhes)

                if status == "LENDO":
                    mc.postToChat("üì∂ Lendo cart√£o NFC...")
                elif status == "AUTORIZADO":
                    mc.postToChat("‚úÖ Acesso autorizado! Iniciando encena√ß√£o m√°gica...")
                    encenacao_completa(mc)
                elif status == "NEGADO":
                    mc.postToChat("üö´ Acesso negado! Limpando √°rea...")
                    limpar_encenacao(mc)
                elif status == "READY":
                    mc.postToChat("üü° Sistema pronto para nova encena√ß√£o.")
            time.sleep(0.1)  # Reduz uso de CPU
        except Exception as e:
            registrar_log("ERROR", f"Erro no loop principal: {e}")
            time.sleep(1)
except KeyboardInterrupt:
    print("[INFO] Script interrompido pelo usu√°rio (Ctrl+C)")
    registrar_log("STOP", "Script interrompido pelo usu√°rio")
    arduino.close()
    print("[INFO] Conex√£o com Arduino fechada")
    exit(0)